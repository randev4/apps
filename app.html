<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circle Explorer & Challenge</title>
    <style>
        /* 
         * =============================================
         * General & Mobile-First Styles
         * =============================================
         * Base styles are optimized for small screens first.
         * Larger screen adjustments are handled in the media query at the end.
        */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 10px; /* Reduced padding for mobile */
            background-color: #f4f7f6;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            box-sizing: border-box;
        }

        #app-container {
            background-color: #fff;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 900px;
            overflow: hidden;
            padding: 15px; /* Reduced padding for mobile */
            box-sizing: border-box;
        }

        header {
            text-align: center;
            margin-bottom: 20px; /* Reduced margin */
            border-bottom: 1px solid #eee;
            padding-bottom: 15px; /* Reduced padding */
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.8em; /* Smaller font size for mobile */
        }

        h2 {
            color: #34495e;
            margin-bottom: 20px;
            font-size: 1.4em; /* Smaller font size for mobile */
            text-align: center;
        }

        h3 {
            color: #34495e;
            margin-top: 25px;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .mode-switcher {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }

        .mode-switcher button {
            padding: 10px 20px; /* Adjusted padding for mobile tappability */
            font-size: 1em; /* Adjusted font size */
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            background-color: #ecf0f1;
            color: #34495e;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
        }

        .mode-switcher button.active {
            background-color: #3498db;
            color: white;
            box-shadow: 0 4px 8px rgba(52, 152, 219, 0.3);
            transform: translateY(-2px);
        }

        .mode-switcher button:hover:not(.active) {
            background-color: #dfe6e9;
            transform: translateY(-1px);
        }

        .mode-section {
            display: none;
            padding-top: 20px;
        }

        .mode-section.active {
            display: block;
        }

        /* Explore Mode Specifics */
        .concept-display {
            text-align: center;
            margin-bottom: 20px; /* Reduced margin */
            padding: 15px;
            background-color: #e8f4f8;
            border-radius: 8px;
            border: 1px solid #d0e7f2;
        }

        .concept-display p {
            font-size: 1em; /* Adjusted font size */
            line-height: 1.6;
            color: #2c3e50;
        }

        .canvas-container {
            display: flex;
            flex-direction: column; /* Default: stack vertically on mobile */
            gap: 20px; /* Reduced gap */
            align-items: center;
        }

        #circleCanvas, #challengeCanvas {
            border: 2px solid #3498db;
            background-color: #fdfdfd;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            width: 100%; /* Make canvas responsive */
            max-width: 500px;
            height: auto;
            aspect-ratio: 1 / 1; /* Keep it square */
        }

        .circle-info {
            background-color: #f7f9fb;
            border: 1px solid #e0e6eb;
            border-radius: 8px;
            padding: 20px; /* Reduced padding */
            width: 100%;
            max-width: 380px;
            box-sizing: border-box;
        }

        .circle-info p {
            font-size: 1em; /* Adjusted font size */
            margin-bottom: 8px;
            line-height: 1.5;
        }

        #circleEquation {
            font-family: 'Courier New', Courier, monospace;
            background-color: #ecf0f1;
            padding: 15px;
            border-radius: 6px;
            font-size: 1.1em; /* Adjusted for readability */
            color: #2c3e50;
            white-space: pre-wrap;
            word-break: break-all;
            text-align: center;
        }

        /* Challenge Mode Specifics */
        .challenge-area {
            background-color: #f7f9fb;
            border: 1px solid #e0e6eb;
            border-radius: 8px;
            padding: 20px; /* Reduced padding */
            box-sizing: border-box;
            text-align: center;
        }

        #scoreDisplay {
            font-size: 1.2em;
            font-weight: bold;
            color: #2980b9;
            margin-bottom: 20px;
        }

        #questionText {
            font-size: 1.15em; /* Adjusted font size for mobile */
            margin-bottom: 25px;
            line-height: 1.6;
            color: #2c3e50;
        }

        .options-grid {
            display: grid;
            grid-template-columns: 1fr; /* Default to single column for mobile */
            gap: 15px;
            margin-bottom: 25px;
        }

        .option-button {
            padding: 12px 15px; /* Adjusted padding */
            font-size: 1em; /* Adjusted font size */
            border: 1px solid #bdc3c7;
            border-radius: 8px;
            background-color: #ecf0f1;
            color: #34495e;
            cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease, transform 0.1s ease;
            text-align: left;
            word-wrap: break-word;
        }

        .option-button:hover {
            background-color: #dfe6e9;
            border-color: #95a5a6;
        }

        .option-button.selected {
            background-color: #3498db;
            color: white;
            border-color: #2980b9;
        }

        .option-button.correct {
            background-color: #27ae60;
            color: white;
            border-color: #229954;
        }

        .option-button.incorrect {
            background-color: #e74c3c;
            color: white;
            border-color: #c0392b;
        }

        #feedbackMessage {
            margin-top: 20px;
            font-size: 1.1em;
            font-weight: bold;
            min-height: 30px;
        }

        #feedbackMessage.correct { color: #27ae60; }
        #feedbackMessage.incorrect { color: #e74c3c; }

        #nextQuestionBtn, #restartQuizBtn {
            padding: 12px 25px;
            font-size: 1.1em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background-color: #2ecc71;
            color: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: background-color 0.3s ease;
            margin-top: 20px;
        }

        #nextQuestionBtn:disabled {
            background-color: #aed6f1;
            cursor: not-allowed;
        }

        #nextQuestionBtn:hover:not(:disabled), #restartQuizBtn:hover {
            background-color: #27ae60;
        }

        #restartQuizBtn { background-color: #e67e22; }
        #restartQuizBtn:hover { background-color: #d35400; }

        /* 
         * =============================================
         * Responsive Adjustments for Larger Screens
         * =============================================
         * Media query for tablets and desktops (768px and wider).
         * Styles here override the mobile-first styles for a more spacious layout.
        */
        @media (min-width: 768px) {
            body {
                padding: 20px; /* Restore larger padding */
            }

            #app-container {
                padding: 30px; /* Restore larger padding */
            }
            
            h1 {
                font-size: 2.2em; /* Restore larger font size */
            }

            h2 {
                font-size: 1.6em; /* Restore larger font size */
            }

            .mode-switcher button {
                padding: 12px 25px; /* Restore larger padding */
                font-size: 1.1em;
            }

            .canvas-container {
                flex-direction: row; /* Side-by-side layout on larger screens */
                justify-content: center;
                align-items: flex-start;
                gap: 30px; /* Increase gap for spacious layout */
            }

            .circle-info {
                max-width: 300px;
                padding: 25px; /* Restore larger padding */
            }

            #circleCanvas {
                max-width: 450px;
            }
            
            #questionText {
                font-size: 1.3em; /* Restore larger font size */
            }

            .options-grid {
                grid-template-columns: 1fr 1fr; /* Two columns for options */
            }

            .option-button {
                padding: 15px 20px; /* Restore larger padding */
                font-size: 1.1em;
            }
        }
    </style>
</head>
<body>
    <div id="app-container">
        <header>
            <h1>Circles: Explore & Challenge</h1>
            <div class="mode-switcher">
                <button id="exploreModeBtn" class="active">Explore</button>
                <button id="challengeModeBtn">Challenge</button>
            </div>
        </header>

        <main>
            <section id="explore-mode" class="mode-section active">
                <div class="concept-display">
                    <h2>Explore Circles</h2>
                    <p><strong>Definition:</strong> A circle is a set of all points in a plane that are equidistant from a fixed point, called the center.</p>
                </div>
                <div class="canvas-container">
                    <canvas id="circleCanvas"></canvas>
                    <div class="circle-info">
                        <h3>Current Circle Properties:</h3>
                        <p>Center (h, k): <span id="centerCoords">(0, 0)</span></p>
                        <p>Radius (r): <span id="radiusValue">0</span></p>
                        <p>Radius Squared (r²): <span id="radiusSquaredValue">0</span></p>
                        <h3>Equation:</h3>
                        <p id="circleEquation">(x - 0)² + (y - 0)² = 0</p>
                    </div>
                </div>
            </section>

            <section id="challenge-mode" class="mode-section">
                <h2>Challenge Your Knowledge</h2>
                <div class="challenge-area">
                    <p id="scoreDisplay">Score: 0/0</p>
                    <div id="questionContainer">
                        <p id="questionText">Loading question...</p>
                        <canvas id="challengeCanvas" style="display: none;"></canvas>
                        <div id="optionsContainer" class="options-grid">
                            <!-- Options will be dynamically inserted here -->
                        </div>
                        <p id="feedbackMessage"></p>
                        <button id="nextQuestionBtn" disabled>Next Question</button>
                        <button id="restartQuizBtn" style="display: none;">Restart Quiz</button>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const exploreModeBtn = document.getElementById('exploreModeBtn');
            const challengeModeBtn = document.getElementById('challengeModeBtn');
            const exploreModeSection = document.getElementById('explore-mode');
            const challengeModeSection = document.getElementById('challenge-mode');

            const exploreCanvas = document.getElementById('circleCanvas');
            const exploreCtx = exploreCanvas.getContext('2d');
            const centerCoordsDisplay = document.getElementById('centerCoords');
            const radiusValueDisplay = document.getElementById('radiusValue');
            const radiusSquaredValueDisplay = document.getElementById('radiusSquaredValue');
            const circleEquationDisplay = document.getElementById('circleEquation');

            const challengeCanvas = document.getElementById('challengeCanvas');
            const challengeCtx = challengeCanvas.getContext('2d');
            const scoreDisplay = document.getElementById('scoreDisplay');
            const questionTextDisplay = document.getElementById('questionText');
            const optionsContainer = document.getElementById('optionsContainer');
            const feedbackMessage = document.getElementById('feedbackMessage');
            const nextQuestionBtn = document.getElementById('nextQuestionBtn');
            const restartQuizBtn = document.getElementById('restartQuizBtn');

            // --- Configuration Constants ---
            const CANVAS_LOGICAL_SIZE = 20; // Represents the range from -10 to 10 on each axis
            const CANVAS_PIXEL_SIZE = 500; // HTML canvas width/height attribute
            const AXIS_STEP = 2; // How often to draw axis labels (e.g., at -8, -6, ..., 6, 8)
            const RADIUS_HANDLE_SIZE = 10; // Pixels for the radius drag handle
            const MIN_EXPLORE_RADIUS = 0.5; // Minimum radius for explore mode
            const MAX_EXPLORE_RADIUS = 9; // Max radius to stay within bounds

            const NUM_CHALLENGE_QUESTIONS = 5; // Number of questions per quiz session
            const MAX_CHALLENGE_RADIUS = 8;
            const MIN_CHALLENGE_RADIUS = 2;

            // --- Global State ---
            let currentMode = 'explore';
            let exploreCircle = { h: 0, k: 0, r: 5, r_sq: 25 };
            let isDraggingCenter = false;
            let isDraggingRadius = false;
            let dragOffsetX = 0;
            let dragOffsetY = 0;

            let challengeState = {
                score: 0,
                totalQuestions: 0,
                currentQuestionIndex: -1,
                questions: [],
                currentQuestion: null,
                optionsLocked: false
            };

            // --- Helper Functions ---

            /**
             * Converts Cartesian coordinates (logical units) to canvas pixel coordinates.
             * @param {number} x Cartesian x-coordinate.
             * @param {number} y Cartesian y-coordinate.
             * @param {number} canvasSize The pixel size of the canvas (width/height).
             * @param {number} logicalSize The logical range (e.g., 20 for -10 to 10).
             * @returns {{cx: number, cy: number}} Canvas pixel coordinates.
             */
            function toCanvasCoords(x, y, canvasSize = CANVAS_PIXEL_SIZE, logicalSize = CANVAS_LOGICAL_SIZE) {
                const scale = canvasSize / logicalSize;
                const cx = (x + logicalSize / 2) * scale;
                const cy = canvasSize - ((y + logicalSize / 2) * scale); // Y-axis is inverted in canvas
                return { cx, cy };
            }

            /**
             * Converts canvas pixel coordinates to Cartesian coordinates (logical units).
             * @param {number} cx Canvas x-pixel.
             * @param {number} cy Canvas y-pixel.
             * @param {number} canvasSize The pixel size of the canvas (width/height).
             * @param {number} logicalSize The logical range (e.g., 20 for -10 to 10).
             * @returns {{x: number, y: number}} Cartesian coordinates.
             */
            function toCartesianCoords(cx, cy, canvasSize = CANVAS_PIXEL_SIZE, logicalSize = CANVAS_LOGICAL_SIZE) {
                const scale = canvasSize / logicalSize;
                const x = (cx / scale) - (logicalSize / 2);
                const y = ((canvasSize - cy) / scale) - (logicalSize / 2);
                return { x, y };
            }

            /**
             * Calculates distance between two points.
             */
            function dist(x1, y1, x2, y2) {
                return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            }

            /**
             * Formats the circle equation string.
             */
            function getEquationString(h, k, r_sq) {
                const hPart = h === 0 ? 'x' : (h > 0 ? `(x - ${h})` : `(x + ${Math.abs(h)})`);
                const kPart = k === 0 ? 'y' : (k > 0 ? `(y - ${k})` : `(y + ${Math.abs(k)})`);
                return `${hPart}² + ${kPart}² = ${r_sq}`;
            }

            /**
             * Generates a random integer within a range.
             */
            function getRandomInt(min, max) {
                min = Math.ceil(min);
                max = Math.floor(max);
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            /**
             * Shuffles an array.
             */
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            // --- Canvas Drawing Functions (General for Explore & Challenge) ---

            function drawAxes(ctx, canvasSize, logicalSize) {
                const scale = canvasSize / logicalSize;
                const originPx = toCanvasCoords(0, 0, canvasSize, logicalSize);

                ctx.clearRect(0, 0, canvasSize, canvasSize);
                ctx.strokeStyle = '#95a5a6';
                ctx.lineWidth = 1;

                // X-axis
                ctx.beginPath();
                ctx.moveTo(0, originPx.cy);
                ctx.lineTo(canvasSize, originPx.cy);
                ctx.stroke();

                // Y-axis
                ctx.beginPath();
                ctx.moveTo(originPx.cx, 0);
                ctx.lineTo(originPx.cx, canvasSize);
                ctx.stroke();

                ctx.font = '14px Arial';
                ctx.fillStyle = '#34495e';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';

                // X-axis labels
                for (let i = -logicalSize / 2; i <= logicalSize / 2; i += AXIS_STEP) {
                    if (i === 0) continue; // Skip origin for now
                    const { cx } = toCanvasCoords(i, 0, canvasSize, logicalSize);
                    ctx.fillText(i, cx, originPx.cy + 5);
                    ctx.beginPath();
                    ctx.moveTo(cx, originPx.cy - 3);
                    ctx.lineTo(cx, originPx.cy + 3);
                    ctx.stroke();
                }

                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                // Y-axis labels
                for (let i = -logicalSize / 2; i <= logicalSize / 2; i += AXIS_STEP) {
                    if (i === 0) continue; // Skip origin for now
                    const { cy } = toCanvasCoords(0, i, canvasSize, logicalSize);
                    ctx.fillText(i, originPx.cx + 5, cy);
                    ctx.beginPath();
                    ctx.moveTo(originPx.cx - 3, cy);
                    ctx.lineTo(originPx.cx + 3, cy);
                    ctx.stroke();
                }

                // Origin label
                ctx.textAlign = 'right';
                ctx.textBaseline = 'top';
                ctx.fillText('(0,0)', originPx.cx - 5, originPx.cy + 5);
            }

            function drawCircle(ctx, h, k, r, canvasSize, logicalSize, isExploreMode = true) {
                const scale = canvasSize / logicalSize;
                const { cx, cy } = toCanvasCoords(h, k, canvasSize, logicalSize);
                const radiusPx = r * scale;

                // Draw circle
                ctx.beginPath();
                ctx.arc(cx, cy, radiusPx, 0, 2 * Math.PI);
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 3;
                ctx.stroke();

                // Draw center point
                ctx.beginPath();
                ctx.arc(cx, cy, 5, 0, 2 * Math.PI);
                ctx.fillStyle = '#e74c3c';
                ctx.fill();

                // Label center
                ctx.font = '16px Arial';
                ctx.fillStyle = '#34495e';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText('Center (h,k)', cx, cy - 10);

                if (isExploreMode) {
                    // Draw radius line and handle
                    const radiusHandleX = cx + radiusPx; // Handle at 3 o'clock position
                    const radiusHandleY = cy;

                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(radiusHandleX, radiusHandleY);
                    ctx.strokeStyle = '#2ecc71';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.arc(radiusHandleX, radiusHandleY, RADIUS_HANDLE_SIZE / 2, 0, 2 * Math.PI);
                    ctx.fillStyle = '#2ecc71';
                    ctx.fill();

                    ctx.font = '16px Arial';
                    ctx.fillStyle = '#34495e';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText('Radius (r)', (cx + radiusHandleX) / 2, (cy + radiusHandleY) / 2 - 5);
                }
            }

            // --- Explore Mode Logic ---

            function drawExploreCanvas() {
                drawAxes(exploreCtx, CANVAS_PIXEL_SIZE, CANVAS_LOGICAL_SIZE);
                drawCircle(exploreCtx, exploreCircle.h, exploreCircle.k, exploreCircle.r, CANVAS_PIXEL_SIZE, CANVAS_LOGICAL_SIZE, true);
            }

            function updateExploreUI() {
                centerCoordsDisplay.textContent = `(${exploreCircle.h.toFixed(1)}, ${exploreCircle.k.toFixed(1)})`;
                radiusValueDisplay.textContent = exploreCircle.r.toFixed(1);
                radiusSquaredValueDisplay.textContent = exploreCircle.r_sq.toFixed(2);
                circleEquationDisplay.textContent = getEquationString(exploreCircle.h, exploreCircle.k, exploreCircle.r_sq.toFixed(2));
            }

            function initExploreMode() {
                // Set canvas dimensions
                exploreCanvas.width = CANVAS_PIXEL_SIZE;
                exploreCanvas.height = CANVAS_PIXEL_SIZE;

                // Initial draw and UI update
                drawExploreCanvas();
                updateExploreUI();

                // Event Listeners for Interaction
                exploreCanvas.addEventListener('mousedown', onMouseDownExplore);
                exploreCanvas.addEventListener('mousemove', onMouseMoveExplore);
                exploreCanvas.addEventListener('mouseup', onMouseUpExplore);
                exploreCanvas.addEventListener('mouseout', onMouseUpExplore); // Stop dragging if mouse leaves canvas
            }

            function onMouseDownExplore(e) {
                const rect = exploreCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const { cx, cy } = toCanvasCoords(exploreCircle.h, exploreCircle.k);
                const radiusPx = exploreCircle.r * (CANVAS_PIXEL_SIZE / CANVAS_LOGICAL_SIZE);

                // Check if dragging center
                if (dist(mouseX, mouseY, cx, cy) < 15) { // Small buffer around center point
                    isDraggingCenter = true;
                    dragOffsetX = mouseX - cx;
                    dragOffsetY = mouseY - cy;
                }
                // Check if dragging radius handle (point on right edge of circle)
                else if (dist(mouseX, mouseY, cx + radiusPx, cy) < RADIUS_HANDLE_SIZE) {
                    isDraggingRadius = true;
                }
            }

            function onMouseMoveExplore(e) {
                if (!isDraggingCenter && !isDraggingRadius) return;

                const rect = exploreCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                if (isDraggingCenter) {
                    const { x, y } = toCartesianCoords(mouseX - dragOffsetX, mouseY - dragOffsetY);
                    exploreCircle.h = parseFloat(x.toFixed(1));
                    exploreCircle.k = parseFloat(y.toFixed(1));
                } else if (isDraggingRadius) {
                    const { x: cartesianMouseX, y: cartesianMouseY } = toCartesianCoords(mouseX, mouseY);
                    let newRadius = dist(exploreCircle.h, exploreCircle.k, cartesianMouseX, cartesianMouseY);

                    // Constrain radius
                    newRadius = Math.max(MIN_EXPLORE_RADIUS, Math.min(newRadius, MAX_EXPLORE_RADIUS));
                    exploreCircle.r = parseFloat(newRadius.toFixed(1));
                }
                exploreCircle.r_sq = parseFloat((exploreCircle.r * exploreCircle.r).toFixed(2));

                drawExploreCanvas();
                updateExploreUI();
            }

            function onMouseUpExplore() {
                isDraggingCenter = false;
                isDraggingRadius = false;
            }

            // --- Challenge Mode Logic ---

            const questionTypes = {
                A: {
                    name: "Identify Properties from Equation",
                    generate: function() {
                        const h = getRandomInt(-MAX_CHALLENGE_RADIUS + 2, MAX_CHALLENGE_RADIUS - 2);
                        const k = getRandomInt(-MAX_CHALLENGE_RADIUS + 2, MAX_CHALLENGE_RADIUS - 2);
                        const r = getRandomInt(MIN_CHALLENGE_RADIUS, MAX_CHALLENGE_RADIUS);
                        const r_sq = r * r;
                        const equation = getEquationString(h, k, r_sq);

                        const correctAnswer = `Center: (${h}, ${k}), Radius: ${r}`;
                        const options = [
                            correctAnswer,
                            `Center: (${-h}, ${-k}), Radius: ${r}`, // Incorrect signs for center
                            `Center: (${h}, ${k}), Radius: ${r_sq}`, // Incorrect radius (r^2)
                            `Center: (${k}, ${h}), Radius: ${r}` // Swapped center coords
                        ];
                        shuffleArray(options);
                        const correctIndex = options.indexOf(correctAnswer);

                        return {
                            type: 'A',
                            question: `What are the center and radius of the circle with the equation ${equation}?`,
                            options: options,
                            correctAnswerIndex: correctIndex,
                            hint: "Remember to pay attention to the signs for the center coordinates (x-h, y-k) and to take the square root of r² to find the radius!"
                        };
                    }
                },
                B: {
                    name: "Equation from Properties",
                    generate: function() {
                        const h = getRandomInt(-MAX_CHALLENGE_RADIUS + 2, MAX_CHALLENGE_RADIUS - 2);
                        const k = getRandomInt(-MAX_CHALLENGE_RADIUS + 2, MAX_CHALLENGE_RADIUS - 2);
                        const r = getRandomInt(MIN_CHALLENGE_RADIUS, MAX_CHALLENGE_RADIUS);
                        const r_sq = r * r;

                        const correctAnswer = getEquationString(h, k, r_sq);
                        const options = [
                            correctAnswer,
                            getEquationString(-h, -k, r_sq), // Incorrect center signs
                            getEquationString(h, k, r),      // Incorrect radius squared
                            getEquationString(k, h, r_sq)    // Swapped center coords
                        ];
                        shuffleArray(options);
                        const correctIndex = options.indexOf(correctAnswer);

                        return {
                            type: 'B',
                            question: `Which equation represents a circle with center (${h}, ${k}) and radius ${r}?`,
                            options: options,
                            correctAnswerIndex: correctIndex,
                            hint: "Be careful with the signs for h and k in the equation, and remember it's r² on the right side!"
                        };
                    }
                },
                C: {
                    name: "Equation from Graph",
                    generate: function() {
                        // Ensure center and circle fit within the canvas logical range
                        const r = getRandomInt(MIN_CHALLENGE_RADIUS, Math.floor(CANVAS_LOGICAL_SIZE / 2) - 2); // Max radius to leave some margin
                        const h = getRandomInt(-CANVAS_LOGICAL_SIZE / 2 + r + 1, CANVAS_LOGICAL_SIZE / 2 - r - 1);
                        const k = getRandomInt(-CANVAS_LOGICAL_SIZE / 2 + r + 1, CANVAS_LOGICAL_SIZE / 2 - r - 1);
                        const r_sq = r * r;

                        const correctAnswer = getEquationString(h, k, r_sq);
                        const options = [
                            correctAnswer,
                            getEquationString(-h, -k, r_sq),
                            getEquationString(h, k, r),
                            getEquationString(k, h, r_sq)
                        ];
                        shuffleArray(options);
                        const correctIndex = options.indexOf(correctAnswer);

                        return {
                            type: 'C',
                            question: `Which equation is for the circle graphed below?`,
                            options: options,
                            correctAnswerIndex: correctIndex,
                            hint: "Carefully read the center coordinates and radius from the graph. Remember to square the radius for the equation!",
                            h, k, r // Store these to draw the circle
                        };
                    }
                },
                D: {
                    name: "Quadrant Identification",
                    generate: function() {
                        let h = getRandomInt(-MAX_CHALLENGE_RADIUS, MAX_CHALLENGE_RADIUS);
                        let k = getRandomInt(-MAX_CHALLENGE_RADIUS, MAX_CHALLENGE_RADIUS);
                        // Ensure h and k are not zero for clear quadrant identification
                        if (h === 0) h = (Math.random() < 0.5 ? 1 : -1) * getRandomInt(1, MAX_CHALLENGE_RADIUS);
                        if (k === 0) k = (Math.random() < 0.5 ? 1 : -1) * getRandomInt(1, MAX_CHALLENGE_RADIUS);

                        const r = getRandomInt(MIN_CHALLENGE_RADIUS, MAX_CHALLENGE_RADIUS);
                        const r_sq = r * r;
                        const equation = getEquationString(h, k, r_sq);

                        let quadrant;
                        if (h > 0 && k > 0) quadrant = 'Quadrant I';
                        else if (h < 0 && k > 0) quadrant = 'Quadrant II';
                        else if (h < 0 && k < 0) quadrant = 'Quadrant III';
                        else if (h > 0 && k < 0) quadrant = 'Quadrant IV';
                        
                        const possibleQuadrants = ['Quadrant I', 'Quadrant II', 'Quadrant III', 'Quadrant IV'];
                        let options = possibleQuadrants.filter(q => q !== quadrant); // Get 3 incorrect options
                        options.splice(getRandomInt(0,3), 0, quadrant); // Insert correct answer randomly
                        options = options.slice(0,4); // Ensure only 4 options

                        shuffleArray(options);
                        const correctIndex = options.indexOf(quadrant);

                        return {
                            type: 'D',
                            question: `In which quadrant is the center of the circle ${equation} located?`,
                            options: options,
                            correctAnswerIndex: correctIndex,
                            hint: "Remember the signs of coordinates in each quadrant: Quadrant I (+,+), Quadrant II (-,+), Quadrant III (-,-), Quadrant IV (+,-)."
                        };
                    }
                }
            };

            function generateQuizQuestions() {
                challengeState.questions = [];
                const questionTypeKeys = Object.keys(questionTypes);
                for (let i = 0; i < NUM_CHALLENGE_QUESTIONS; i++) {
                    const randomTypeKey = questionTypeKeys[getRandomInt(0, questionTypeKeys.length - 1)];
                    challengeState.questions.push(questionTypes[randomTypeKey].generate());
                }
            }

            function loadQuestion() {
                challengeState.currentQuestionIndex++;
                if (challengeState.currentQuestionIndex >= NUM_CHALLENGE_QUESTIONS) {
                    endQuiz();
                    return;
                }

                challengeState.currentQuestion = challengeState.questions[challengeState.currentQuestionIndex];
                challengeState.optionsLocked = false;

                questionTextDisplay.textContent = challengeState.currentQuestion.question;
                feedbackMessage.textContent = '';
                feedbackMessage.className = ''; // Remove correct/incorrect class
                nextQuestionBtn.disabled = true;
                restartQuizBtn.style.display = 'none'; // Hide restart button initially

                // Clear previous options
                optionsContainer.innerHTML = '';
                challengeCanvas.style.display = 'none'; // Hide canvas by default

                // Render options
                challengeState.currentQuestion.options.forEach((option, index) => {
                    const button = document.createElement('button');
                    button.classList.add('option-button');
                    button.textContent = option;
                    button.dataset.index = index;
                    button.addEventListener('click', () => selectOption(index, button));
                    optionsContainer.appendChild(button);
                });

                // If it's a graph question, draw the circle
                if (challengeState.currentQuestion.type === 'C') {
                    challengeCanvas.width = CANVAS_PIXEL_SIZE;
                    challengeCanvas.height = CANVAS_PIXEL_SIZE;
                    drawAxes(challengeCtx, CANVAS_PIXEL_SIZE, CANVAS_LOGICAL_SIZE);
                    drawCircle(challengeCtx, challengeState.currentQuestion.h, challengeState.currentQuestion.k, challengeState.currentQuestion.r, CANVAS_PIXEL_SIZE, CANVAS_LOGICAL_SIZE, false);
                    challengeCanvas.style.display = 'block';
                } else {
                    challengeCanvas.style.display = 'none';
                }

                updateScoreDisplay();
            }

            function selectOption(selectedIndex, selectedButton) {
                if (challengeState.optionsLocked) return;
                challengeState.optionsLocked = true;

                const allOptionButtons = optionsContainer.querySelectorAll('.option-button');
                allOptionButtons.forEach(btn => {
                    btn.disabled = true; // Disable all buttons after selection
                    btn.classList.remove('selected');
                });

                selectedButton.classList.add('selected');

                if (selectedIndex === challengeState.currentQuestion.correctAnswerIndex) {
                    feedbackMessage.textContent = 'Correct!';
                    feedbackMessage.classList.add('correct');
                    selectedButton.classList.add('correct');
                    challengeState.score++;
                } else {
                    feedbackMessage.textContent = `Incorrect. Hint: ${challengeState.currentQuestion.hint}`;
                    feedbackMessage.classList.add('incorrect');
                    selectedButton.classList.add('incorrect');
                    // Highlight correct answer
                    allOptionButtons[challengeState.currentQuestion.correctAnswerIndex].classList.add('correct');
                }
                challengeState.totalQuestions++;
                updateScoreDisplay();
                nextQuestionBtn.disabled = false;
            }

            function updateScoreDisplay() {
                scoreDisplay.textContent = `Score: ${challengeState.score}/${challengeState.totalQuestions}`;
            }

            function endQuiz() {
                questionTextDisplay.textContent = `Quiz Finished! You scored ${challengeState.score} out of ${challengeState.totalQuestions}.`;
                optionsContainer.innerHTML = '';
                feedbackMessage.textContent = 'Great job!';
                feedbackMessage.className = 'correct';
                nextQuestionBtn.style.display = 'none';
                restartQuizBtn.style.display = 'block';
                challengeCanvas.style.display = 'none';
            }

            function restartQuiz() {
                challengeState.score = 0;
                challengeState.totalQuestions = 0;
                challengeState.currentQuestionIndex = -1;
                nextQuestionBtn.style.display = 'block';
                restartQuizBtn.style.display = 'none';
                generateQuizQuestions();
                loadQuestion();
            }

            // --- Mode Switching Logic ---

            function switchMode(mode) {
                currentMode = mode;

                exploreModeSection.classList.remove('active');
                challengeModeSection.classList.remove('active');
                exploreModeBtn.classList.remove('active');
                challengeModeBtn.classList.remove('active');

                if (mode === 'explore') {
                    exploreModeSection.classList.add('active');
                    exploreModeBtn.classList.add('active');
                    // Ensure canvas is ready
                    drawExploreCanvas();
                    updateExploreUI();
                } else { // challenge mode
                    challengeModeSection.classList.add('active');
                    challengeModeBtn.classList.add('active');
                    restartQuiz(); // Always restart quiz when entering challenge mode
                }
            }

            // --- Initial Setup ---
            initExploreMode();
            generateQuizQuestions(); // Generate questions initially

            // Event Listeners for Mode Buttons
            exploreModeBtn.addEventListener('click', () => switchMode('explore'));
            challengeModeBtn.addEventListener('click', () => switchMode('challenge'));
            nextQuestionBtn.addEventListener('click', loadQuestion);
            restartQuizBtn.addEventListener('click', restartQuiz);

            // Set initial mode
            switchMode('explore');
        });
    </script>
</body>
</html>